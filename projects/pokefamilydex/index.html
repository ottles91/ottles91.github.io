<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PokeFamilyDex - Cameron Ottley</title>
  <script src="/js/includes.js"></script>
  <!-- Highlight.js styles -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <!-- Highlight.js script -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
  <link rel="stylesheet" href="/css/styles.css" />
</head>

<body>
  <div id="header-placeholder"></div>
  <div class="container">
    <main class="content">
      <h1>PokeFamilyDex</h1>
      <p>
        This Python script generates a clean, human-readable National
        Dex-ordered list of Pokémon grouped by evolutionary family. This is a
        passion project of mine. I've always wanted to organize my Pokemon
        Home boxes by Pokemon family, but as far as I can tell there is no
        resource out there that clealy organizes Pokemon by family. I wanted
        to create a tool that would allow me to do this, and I hope it will be
        useful to others as well. The script is designed to be run in a Python
        environment and outputs the list in a text format that can be easily
        copied into a document or spreadsheet.
      </p>
      <ul>
        <li>
          Repository:
          <a href="https://github.com/ottles91/PokeFamilyDex" target="_blank">github.com/ottles91/PokeFamilyDex</a>
        </li>
      </ul>
      <!-- Table of Contents -->
      <div class="toc-wrapper">
        <button class="toc-master-toggle" aria-expanded="true">
          Table of Contents
        </button>
        <nav class="toc" id="toc-content">
          <ul>
            <li><a href="#philosophy">Philosophy</a></li>
            <li><a href="#dexorder">My Problem with National Pokedex Order</a></li>
            <li><a href="#techstack">Tech Stack</a></li>
            <li><a href="#features">Key Features</a></li>
            <li>
              <a href="#details">Technical Details</a>
              <ul>
                <li><a href="#architecture">Architecture</a></li>
                <li><a href="#algorithm">Algorithm Design</a></li>
                <li><a href="#edgecases">Edge Case Handling</a></li>
              </ul>
            </li>
            <li><a href="#challenges">Implementation Challenges</a></li>
            <li><a href="#whatilearned">What I Learned</a></li>
            <li><a href="#upcomingfeatures">Upcoming Features</a></li>
          </ul>
        </nav>
      </div>
      <details open class="collapsible-section">
        <summary>
          <span class="summary-title" id="philosophy">Philosophy</span>
        </summary>
        <p>
          I've enjoyed Pokémon since I was a child. I fondly remember going to
          my friend's house and playing <strong>Pokémon Red</strong> on his
          GameBoy Color. Sometimes he would let me borrow his GameBoy, and I
          would take it home and play for hours, desperately trying to get as
          far as I could.
        </p>
        <p>
          I remember struggling to beat Brock with my Charmander. It made
          perfect sense to me — with enough heat, rocks could melt, so
          obviously my fire-type Charmander could beat Brock's Onix.
          Unfortunately, I didn't really understand how type matchups worked,
          and I always hit a wall there.
        </p>

        <p>
          What intrigued me about Pokemon wasn't the battling — I was never
          great at it, and honestly, I still don't find it that particuraly
          fun. What I loved was the
          <strong>collection</strong> aspect. There was this big, long list of
          unknown Pokémon out there <strong>somewhere</strong>, waiting to be
          discovered. I loved running through tall grass, never knowing what
          I'd encounter next... it was magical.
        </p>
        <p>
          Watching my Pokédex slowly fill up was the most satisfying part of
          the game for me.
        </p>

        <h4>The Impetus</h4>
        <p>
          In the summer of 2016, <strong>Pokémon Go</strong> launched — and
          like many others, it pulled me back in. Most people I knew played
          for a couple months and then moved on. I didn't. Not only did I keep
          playing, but I also dove back into the main series games that I'd
          missed growing up.
        </p>
        <p>
          Back then, there were only 150 Pokémon (or 151, if you counted the
          playground rumors about Mew hiding under a truck). Now there were
          over 800 — and I was once again hooked.
        </p>
        <p>
          Over the next few years, I slowly played through
          <em>Alpha Sapphire</em>, <em>X</em>, and <em>Ultra Moon</em>.
          Between those three games, I was able to collect almost all
          available Pokémon (minus a few legendaries and event-only
          mythicals).
        </p>
        <p>
          That's when my organizational instincts kicked in. I wanted to put
          all of them in one place — in a way that felt
          <strong>logical</strong>.
        </p>
      </details>

      <details open class="collapsible-section">
        <summary>
          <span class="summary-title" id="dexorder">My Problem with National Pokedex Order</span>
        </summary>
        <p>
          The most common way to organize Pokémon is by their
          <strong>National Pokédex number</strong>, which lists Pokémon
          chronologically based on the region they were introduced in.
        </p>
        <p>
          While that makes sense historically, it always bothered me in one
          specific way: Pokémon families that were expanded in later
          generations often get split up. One of the clearest examples is the
          Mr. Mime line:
        </p>

        <ul class="pokemon-list" <li>Mime Jr.</li>
          <li>Mr. Mime</li>
          <li>Mr. Mime (Galarian Form)</li>
          <li>Mr. Rime</li>
        </ul>

        <p>In National Dex order, this family appears like this:</p>
        <ul class="pokemon-list">
          <li>Mr. Mime (Slot 122)</li>
          <li>Mime Jr. (Slot 439)</li>
          <li>Mr. Rime (Slot 866)</li>
        </ul>

        <p>
          That splits the family across hundreds of entries and ignores
          regional form differences. Galarian Mr. Mime often gets skipped
          entirely.
        </p>

        <p>
          Another good usecase for organizing by family is the Eevee line.
          Eevee has a total of 8 evoultions, but they're spread across four
          different generations, meaning that they're not typically organized
          together. My script makes sure that the entire Eevee line can be
          seen together in one location:
        </p>
        <ul class="pokemon-list">
          <li>Eevee</li>
          <li>Vaporeon</li>
          <li>Jolteon</li>
          <li>Flareon</li>
          <li>Espeon</li>
          <li>Leafeon</li>
          <li>Glaceon</li>
          <li>Sylveon</li>
        </ul>

        <p>
          The generation 4 games (Diamond, Pearl and Platinum) in particular
          added nearly 30 Pokemon into previously-existing evolutionary
          families, many originating from Pokemon Red, Green, Blue and Yellow.
          I believe this generation in particular presents the strongest
          argument for organzing Pokemon by evolutionary family rather than
          strictly by Pokedex number. New additions to previouly-established
          Pokemon evolutionary lines include:
        </p>

        <ol class="pokemon-list">
          <li>Budew</li>
          <li>Roserade</li>
          <li>Ambipom</li>
          <li>Mismagius</li>
          <li>Honchkrow</li>
          <li>Chingling</li>
          <li>Bonsly</li>
          <li>Mime Jr.</li>
          <li>Happiny</li>
          <li>Munchlax</li>
          <li>Mantyke</li>
          <li>Weavile</li>
          <li>Magnezone</li>
          <li>Lickilicky</li>
          <li>Rhyperior</li>
          <li>Tangrowth</li>
          <li>Electivire</li>
          <li>Magmortar</li>
          <li>Togekiss</li>
          <li>Yanmega</li>
          <li>Leafeon</li>
          <li>Glaceon</li>
          <li>Gliscor</li>
          <li>Mamoswine</li>
          <li>Porygon-Z</li>
          <li>Gallade</li>
          <li>Probopass</li>
          <li>Dusknoir</li>
          <li>Froslass</li>
        </ol>

        <p>
          Over time, I realized how much I enjoyed seeing all of my Pokémon organized
          by their specific evolutionary families. I began manually sorting my collection
          in Pokémon Home this way, but as new games were released—bringing with them new
          forms and evolutions—it became increasingly difficult to keep everything
          neatly organized. What started as a fun system quickly became tedious to maintain.
        </p>

        <h4>Why I Built This</h4>
        <p>
          After manually organizing my Pokémon in Pokémon Home more times than
          I'd like to admit, I realized:
          <strong>why not automate it?</strong> Instead of scrolling through
          spreadsheets and constantly dragging Pokémon into new boxes, I could
          write a script to group them by family — exactly the way I wanted —
          and output a clean, readable list.
        </p>
        <p>
          This approach is especially helpful for collectors. It's designed to
          group all members of a family together, even if they were introduced
          in different generations or have regional forms.
          <strong>No more missing evolutions, skipped forms, or scattered
            duplicates.</strong>
          It turns the National Dex into something that feels tailored to
          completionists and box-organizers like me.
        </p>

        <p>
          My goal with this project was to create a listing that organizes
          Pokémon based on two priorities:
        </p>

        <ol>
          <li><strong>Evolutionary family</strong> comes first</li>
          <li>Then, <strong>National Pokédex order</strong></li>
        </ol>
      </details>

      <h1>TODO: ADD SECTION FOR FAMILY POKEDEX ORDER AND INCLUDE SCREENSHOTS</h1>


      <details open class="collapsible-section">
        <summary>
          <span class="summary-title" id="techstack">Tech Stack</span>
        </summary>
        <ul>
          <li>
            <strong>Python 3.12</strong> — The entire script is written in modern Python, taking advantage of features
            like <code>match-case</code> statements and built-in type annotations to keep the code clean and readable. I
            chose Python because it's flexible, approachable, and highly adaptable. Since this isn't a script that needs
            to run constantly, performance wasn't a major concern — what mattered more was having something I could
            easily tweak and adjust as my needs evolved.
          </li>
          <li>
            <strong>PokéAPI</strong> — A public RESTful API that provides all the evolution chain, species, and form
            data this script relies on. This project wouldn't be possible without it. The API is impressively
            well-structured and consistent, and I'm grateful to the maintainers. You can explore it yourself
            <a href="https://pokeapi.co/" target="_blank">here</a>.
          </li>
          <li>
            <strong>Requests Library</strong> — Used to fetch data from the PokéAPI. It's a lightweight, no-fuss library
            that makes working with HTTP requests in Python really simple.
          </li>
        </ul>
      </details>

      <details open class="collapsible-section">
        <summary>
          <span class="summary-title" id="features">Key Features</span>
        </summary>
        <ul>
          <li>
            <strong>National Dex + Family-Based Sorting</strong> — The script intelligently groups Pokémon by
            evolutionary family first, then orders those families by National Dex number. This hybrid system keeps
            related forms and evolutions together, even when they span generations.
          </li>
          <li>
            <strong>Accurate Handling of Regional Forms</strong> — Pokémon with region-specific forms (like Galarian Mr.
            Mime or Hisuian Zorua) are included and grouped appropriately, so no variants are accidentally left out.
          </li>
          <li>
            <strong>Readable Output Format</strong> — The script outputs a clean, plain-text list that's easy to copy
            into a document or spreadsheet for organizing Pokémon Home boxes or collection trackers.
          </li>
          <li>
            <strong>One-Command Simplicity</strong> — Run the script once and get a complete, formatted list — no setup
            or extra tooling needed beyond Python and an internet connection.
          </li>
        </ul>
        <h4>Example Output</h4>
        <p>
          Once the data is retrieved from PokéAPI, the script generates a plain-text output file. Here's a sample of the
          formatted results you can expect:
        </p>
        <pre class="bold-pre">
          Voltorb
          Voltorb (Hisui)
          Electrode
          Electrode (Hisui)
          Exeggcute
          Exeggutor
          Exeggutor (Alola)
          Cubone
          Marowak
          Marowak (Alola)
          Marowak (Totem)
          Lickitung
          Lickilicky
          Koffing
          Weezing
          Weezing (Galar)
          Rhyhorn
          Rhydon
          Rhyperior
          Tangela
          Tangrowth
          Kangaskhan
          Horsea
          Seadra   
          Kingdra
          </pre>
        </pre>
      </details>

      <details open class="collapsible-section">
        <summary>
          <span class="summary-title" id="details">Technical Details</span>
        </summary>
        <div class="screenshot-section">
          <figure class="screenshot-figure">
            <img src="/projects/pokefamilydex/images/PokeFamilyDex Flow.jpeg"
              alt="An image showing the technical pipeline of the PokeFamilyDex script" class="screenshot-img"
              loading="lazy">
            <figcaption class="screenshot-caption">The Technical Pipeline of PokeFamilyDex</figcaption>
          </figure>
          <div class="screenshot-details">
            <p>
              The PokeFamilyDex script is built around a simple but effective pipeline: first fetch the raw Pokemon data
              via
              PokéAPI, transform it into logical family groupings, and output it in a clean, readable format that
              prioritizes individual evolution families. While
              the goal is straightforward, the process involves several key steps to ensure accuracy, especially when
              dealing with branching evolutions, regional forms, and other edge cases. Below is a breakdown of the
              technical
              flow behind the script:
            </p>
          </div>
        </div>
        <ol>
          <li>
            <strong>Fetch all species data</strong>
            <p>The script begins by calling the <code>/pokemon-species</code> endpoint from PokéAPI to retrieve metadata
              for every Pokémon species. This includes the evolution chain URL for each species.</p>
          </li>
          <li>
            <strong>Retrieve and parse evolution chains</strong>
            <p>For each evolution chain, the script walks the structure recursively to flatten it into a linear list of
              Pokémon. This ensures that branched evolutions and multi-stage families remain grouped.</p>
            <pre><code class="language-python">
                def flatten_chain(chain):
                  names = [get_display_name(chain["species"])]
                  for evo in chain.get("evolves_to", []):
                    names.extend(flatten_chain(evo))
                  return names
              </code></pre>
          </li>
          <li>
            <strong>Account for alternate forms</strong>
            <p>The script checks the <code>varieties</code> field for alternate forms (e.g., Galarian, Hisuian, Alolan).
              When one is detected, it modifies the display name to include the form label.</p>
            <pre><code class="language-python">
                def get_display_name(species):
                  name = species["name"].title()
                  if "galar" in name.lower():
                    return f"{name} (Galar)"
                  if "hisui" in name.lower():
                    return f"{name} (Hisui)"
                  if "alola" in name.lower():
                    return f"{name} (Alola)" 
                  return name</code></pre>
          </li>
          <li>
            <strong>Local File Caching</strong>
            <p>
              To avoid making repeated requests to PokéAPI, the script caches API responses as JSON files locally. If a
              cached version is available, the script uses it instead of calling the API again.
            </p>
          </li>
          <li>
            <strong>Sort Evolutionary Families</strong>
            <p>
              Once all evolutionary families are gathered, they are sorted by the lowest National Dex number found
              within each family. This mostly preserves Dex order while keeping families grouped.
            </p>
          </li>
          <li>
            <strong>Handling Edge Cases</strong>
          </li>
          <li>
            <strong>Generate the Output File</strong>
            <p>
              The final step is writing the output to a
              <code>.txt</code> file. Each evolutionary family is printed on its
              own,
              grouped together and separated from the next. This makes it easy to copy into a document or spreadsheet.
            </p>
            <p>
              Example:
            </p>
            <pre class="bold-pre">
              Voltorb
              Voltorb (Hisui)
              Electrode
              Electrode (Hisui)
              Exeggcute
              Exeggutor
              Exeggutor (Alola)
            </pre>
          </li>
        </ol>
      </details>

      <details open class="collapsible-section">
        <summary>
          <span class="summary-title" id="architecture">Architecture</span>
        </summary>
        <p>The architecture of the PokeFamilyDex script is designed around clarity, separation of concerns, and
          long-term maintainability. While it's a single-file script at the moment, the internal structure reflects
          modular thinking and careful flow management.</p>

        <h4>Key Architectural Elements</h4>
        <ul>
          <li>
            <strong>Functional Segmentation</strong>
            <p>The script is divided into clearly scoped functions, each with a single responsibility:</p>
            <ul>
              <li><code>get_all_species_data()</code> — Fetches all Pokémon species from the PokéAPI.</li>
              <li><code>get_evolution_chain()</code> — Retrieves the full evolution structure for a given species.</li>
              <li><code>flatten_chain()</code> — Walks an evolution chain recursively to produce a linear family list.
              </li>
              <li><code>build_family_list()</code> — Deduplicates and builds the final ordered output.</li>
            </ul>
          </li>
          <li>
            <strong>Centralized Caching</strong>
            <p>
              To avoid unnecessary API calls during repeated script runs or debugging, the script caches both species
              data and evolution chain responses to local JSON files (<code>species_cache.json</code> and
              <code>evo_cache.json</code>). This dramatically speeds up development cycles and makes it possible to test
              the script offline.
            </p>
          </li>
          <li>
            <strong>Loose Coupling of Data Sources</strong>
            <p>
              Species data and evolution chains are treated as independent sources. This makes it easy to swap out or
              supplement PokéAPI with additional data in the future (like official sprite URLs, form descriptions,
              etc.).
            </p>
          </li>
          <li>
            <strong>Priority-Based Sorting</strong>
            <p>
              Once all data is fetched and parsed, the script builds a final list of families based on two sorting
              priorities:
            </p>
            <ol>
              <li>Evolutionary groupings (i.e., all forms and evolutions are clustered together)</li>
              <li>National Dex order (based on the earliest numbered member of each family)</li>
            </ol>
          </li>
          <li>
            <strong>Minimal Global State</strong>
            <p>With the exception of the caches and a few constants, most functions do not rely on shared global
              variables. This makes the script easier to reason about, test, and refactor.</p>
          </li>
        </ul>
        <p>The architecture reflects the idea that even utility scripts deserve thoughtful structure. While
          PokeFamilyDex is not a large-scale application, organizing the logic this way lets me maintain and evolve the
          project with confidence—especially as more complex branching evolutions, alternate forms, and exceptions are
          added.</p>
      </details>

      <details open class="collapsible-section">
        <summary>
          <span class="summary-title" id="algorithm">Algorithm Design</span>
        </summary>
        <p>The heart of this project lies in its ability to <strong>determine and preserve Pokémon family
            groupings</strong> in a way that feels natural to collectors. While the logic may seem straightforward at
          first glance, building an accurate, de-duplicated, and evolution-aware list required some careful planning.
        </p>
        <ol>
          <li>
            <strong>Recursive Traversal of Evolution Chains</strong>
            <p>Evolution chains in the PokéAPI are nested structures — a base Pokémon evolves into another, which may
              then evolve further, and so on. To handle these variable-depth trees, I wrote a recursive function that
              walks each chain and flattens it into a simple list. Take for example, the Ralts line, whose evolution
              line is shown here:</p>
            <figure class="screenshot-figure">
              <img src="/projects/pokefamilydex/images/ralts_line.jpeg"
                alt="An image showing full evotionary line of Ralts" class="screenshot-img" loading="lazy">
              <figcaption class="screenshot-caption">The Ralts evolutionary family</figcaption>
            </figure>
            <div class="screenshot-details">
            </div>
            <p>By recursively calling each child node, I can capture all branches in the family — including split
              evolutions like Gallade that aren't in a straight line
            </p>
          </li>
          <li>
            <strong>Preserving Order Without Duplicates</strong>
            <p>
              Because many Pokémon appear in multiple chains (like Eevee forms or split evolutions), I needed a way to
              <strong>track seen species</strong> and <strong>only add each family once</strong>. The script uses a
              <code>set()</code> to track added species IDs and skips over repeats.
            </p>
          </li>
          <li>
            <strong>Form Handling & Flattening</strong>
            <p>Some Pokémon have alternate forms (like Meowstic or Zygarde) that show up as separate entries in the API.
              I use logic to:</p>
            <ul>
              <li>Filter out cosmetic-only forms (like Spiky-Eared Pichu or Partner Pikachu)</li>
              <li>
                <p>Keep distinct forms if they evolve differently (like Hoenn vs. Galarian Zigzagoon)</p>
              </li>
            </ul>
            <p>This ensures the list reflects <strong>mechanically relevant forms</strong>, not just visual variants.
            </p>
          </li>
          <li>
            <strong>Family-Based Sorting Strategy</strong>
            <p>Instead of relying on strict numerical order (which splits families across generations), the script
              anchors output by:</p>
            <ol>
              <li>Fetching the <strong>lowest National Dex number</strong> in the family</li>
              <li>Using that number as the family's sorting key</li>
            </ol>
            <p>This means all related Pokémon appear together, even if they were introduced in different generations — a
              must-have when organizing Pokémon Home boxes by family.</p>
          </li>
        </ol>
      </details>

      <details open class="collapsible-section">
        <summary>
          <span class="summary-title" id="edgecases">Edge Case Handling</span>
        </summary>
        <p>Handling edge cases is very important when working with datasets as large as the one provided by the PokéAPI.
          I wanted to handle these as eloquently as possible in order to produce results that I would be happy to use
          for my own Pokemon organization. The evolution system in the Pokemon universe has grown extensively over the
          years, and is now much more complicated that it was back when Pokemon Red, Green and Blue first hit the
          market. Here are some of the edge cases that I had to specifically account for when writing my script:</p>
        <ul>
          <li>
            <strong>Pokemon Species with Multiple Forms</strong>
            <p>Certain Pokemon species include multiple forms that can all be stored in Pokemon Home. Some of these
              include:</p>
            <ul>
              <li><strong>Voltorb</strong> (Kantonian and Hisuian)</li>
              <li><strong>Raichu</strong> (Kantonian and Alolan)</li>
              <li><strong>Deoxys</strong> (Which has Normal, Attack, Defense and Speed forms)</li>
              <li><strong>Basculin</strong> (Red, Blue and White Stripe)</li>
            </ul>
          </li>
          <li>
            <strong>Branching Evolutions</strong>
            <p>Some species, like Eevee, can evolve into multiple different Pokémon depending on conditions like time of
              day, friendship level, items used, or even the player's proximity to a mossy rock. To handle this, my
              script recursively walks the entire evolution chain, collecting all possible evolutions in the correct
              order. This ensures that Pokémon with branching paths still appear together in the same family group.</p>
          </li>
          <li>
            <strong>Regional Forms with Diverging Evolutions</strong>
            <p>Certain Pokémon, like <strong>Yamask</strong>, have different evolutions based on their regional form.
              For example:</p>
            <ul>
              <li>The original (Unovian) <strong>Yamask</strong> evolves into <strong>Cofagrigus</strong></li>
              <li><strong>Galarian Yamask</strong> evolves into <strong>Runerigus</strong> in Pokemon Sword and Pokemon
                Shield</li>
            </ul>
            <p>Because the PokéAPI assigns these forms to the same base species, I had to account for the fact that the
              evolution data might not differentiate between them clearly. In my approach, I wanted to display both
              evolutions in the same family group in order to create a better overview of each Pokemon's entire
              evolutionary family tree.</p>
          </li>
        </ul>
      </details>

      <details open class="collapsible-section">
        <summary>
          <span class="summary-title" id="challenges">Implementation Challenges</span>
        </summary>
        <p>This is the implementation challenges section</p>
      </details>

      <details open class="collapsible-section">
        <summary>
          <span class="summary-title" id="whatilearned">What I Learned</span>
        </summary>
        <p>This is the what I learned section</p>
      </details>

      <details open class="collapsible-section">
        <summary>
          <span class="summary-title" id="upcomingfeatures">Upcoming Features</span>
        </summary>
        <p>This is the upcoming features section</p>
      </details>
    </main>
  </div>
  <div id="footer-placeholder"></div>
  <script src="/js/script.js"></script>
</body>

</html>